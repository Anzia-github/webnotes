- 含义
	- 的是跨站请求伪造攻击
	- 攻击者诱导用户进入一个第三方网站
	- 然后该网站向被攻击网站发送跨站请求
	- 如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作
- 原理
	- 利用了[[cookie]]会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充
- 种类
	1. [[get]]类型的[[CSRF攻击]]
		- 比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交
	2. [[post]]类型的[[CSRF攻击]]
		- 构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单
	3. 链接类型的[[CSRF攻击]]
		- 比如说在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击
- 解决
	1. [[同源]]检测
		- 服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤
		- 同时把搜索引擎的链接也给屏蔽了，所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用
	2. 使用CSRF [[Token]]来进行验证
		- 服务器向用户返回一个随机数[[Token]]，当网站再次发起请求时，在请求参数中加入服务器端返回的[[Token]]，然后服务器对这个[[Token]]进行验证
		- 缺点
			- 需要给网站中的所有请求都添加上这个[[Token]]，操作比较繁琐
			- 如果我们的请求经过负载平衡转移到了其他的服务器，但是这个服务器的session中没有保留这个[[Token]]的话，就没有办法验证了
	3. 双重[[cookie]]验证
		- 服务器在用户访问网站页面时，向请求域名注入一个[[cookie]]
		- 内容为随机字符串，然后当用户再次向服务器发送请求的时候，从[[cookie]]中取出这个字符串，添加到URL参数中
		- 然后服务器通过对[[cookie]]中的数据和参数中的数据进行比较，来进行验证
		- 原理
			- 使用这种方式是利用了攻击者只能利用[[cookie]]，但是不能访问获取[[cookie]]的特点
		- 缺点
			- 如果网站存在[[XSS攻击]]的漏洞，那么这种方式会失效。同时这种方式不能做到子域名的隔离
	4. 设置[[cookie]]属性的时候设置Samesite
		- 限制[[cookie]]不能作为被第三方使用，从而可以避免被攻击者利用
		- Samesite有两种模式
			- 严格模式下
				-  [[cookie]]在任何情况下都不可能作为第三方[[cookie]]使用
			- 宽松模式下
				- [[cookie]]可以被请求是[[get]]请求，且会发生页面跳转的请求所使用